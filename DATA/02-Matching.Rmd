---
title: "Creating Matched Samples for Supermajority Voter Districts"
output:
  html_document:
    theme: readable
    df_print: paged
    highlight: tango
    smart: false
    toc: yes
    toc_float: no
    code_folding: show
---




```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE, warning=F, message=F, fig.width=8)

```




```{r, echo=F}

setwd( "C:/Users/jdlecy/Dropbox/04 - PAPERS/02 - Under Review/25 - Republican and Democratic Nonprofits/Data and Analysis" )


# setwd( "D:/Dropbox/04 - PAPERS/03 - Published/18 - Republican and Democratic Nonprofits/Data and Analysis" )
```


# R Packages


```{r, eval=F}
install.packages( "rgdal" )
install.packages( "acs" )
install.packages( "censusapi" )
install.packages( "MatchIt" )
install.packages( "rgenoud" )
```


```{r}
library( rgdal ) 
library( acs )
library( censusapi )
library( MatchIt )
library( rgenoud )
```



# Census Data

This example uses the **acs** package in R to download 2010 American Community Survey data from the US Census. 

You can find codes for variable names at the Census API site:

<https://api.census.gov/data/2010/acs/acs5/variables.html>



```{r, echo=F}
api.key.install( key="b431c35dad89e2863681311677d12581e8f24c24" )

my.censuskey <- "b431c35dad89e2863681311677d12581e8f24c24"
```


You will need to get a free Census API key: <https://api.census.gov/data/key_signup.html>

```{r, eval=F}
api.key.install( key="your_key_here" )

my.censuskey <- "your_key_here"
```



**NOTE**: This study uses the **acs** package but I would highly recommend using Hannah Recht's **censusapi** package. It is much easier to use!


```{r, eval=F}

# median age  - "B01002A_001"
# hispanic - "B03003_003" 

data2010 <- getCensus( name="acs5", 
                       vintage=2010, 
                       key=my.censuskey, 
                       vars=c("NAME", "B01002A_001E", "B03003_003E", "B17001_001E", "B19013_001E"), 
                       region="tract:*", 
                       regionin="state:48")
```


For replication purposes the original code is included here:



```{r}



i <- "TX"




# median age  - "B01002A_001"
  
my.acs <- acs.fetch( endyear=2010, geo=geo.make( state=i, county="*", tract="*"), variable="B01002A_001" )
  
state <- substr( as.character( my.acs@geography$state + 100 ), 2, 3)
  
county <- substr( as.character( my.acs@geography$county + 1000 ), 2, 4)

tract <- substr( as.character( as.numeric(my.acs@geography$tract) + 1000000 ), 2, 7)

tract.id <- paste( state, county, tract, sep="" )

dat.age <- cbind( tract.id, age=my.acs@estimate[,"B01002A_001"] )





# hispanic - "B03003_003" 

my.acs <- acs.fetch( endyear=2010, 
                     geo=geo.make( state=i, county="*", tract="*"), 
                     variable="B03003_003" )

state <- substr( as.character( my.acs@geography$state + 100 ), 2, 3)

county <- substr( as.character( my.acs@geography$county + 1000 ), 2, 4)

tract <- substr( as.character( as.numeric(my.acs@geography$tract) + 1000000 ), 2, 7)

tract.id <- paste( state, county, tract, sep="" )

dat.hisp <- cbind( tract.id, hispanic=my.acs@estimate[,"B03003_003"] )





# poverty -  "B17001_001"

my.acs <- acs.fetch( endyear=2010, 
                     geo=geo.make( state=i, county="*", tract="*"), 
                     variable="B17001_001" )

state <- substr( as.character( my.acs@geography$state + 100 ), 2, 3)

county <- substr( as.character( my.acs@geography$county + 1000 ), 2, 4)

tract <- substr( as.character( as.numeric(my.acs@geography$tract) + 1000000 ), 2, 7)

tract.id <- paste( state, county, tract, sep="" )

dat.pov1 <- cbind( tract.id, any.income=my.acs@estimate[,"B17001_001"] )

my.acs <- acs.fetch( endyear=2010, 
                     geo=geo.make( state=i, county="*", tract="*"), 
                     variable="B17001_002" )

state <- substr( as.character( my.acs@geography$state + 100 ), 2, 3)

county <- substr( as.character( my.acs@geography$county + 1000 ), 2, 4)

tract <- substr( as.character( as.numeric(my.acs@geography$tract) + 1000000 ), 2, 7)

tract.id <- paste( state, county, tract, sep="" )

dat.pov2 <- cbind( tract.id, inc.below=my.acs@estimate[,"B17001_002"] )

dat.pov <- merge( dat.pov1, dat.pov2 )

dat.pov$inc.below <- as.numeric( as.character( dat.pov$inc.below ) )
dat.pov$any.income <- as.numeric( as.character( dat.pov$any.income ) )
dat.pov$pov.rate <- dat.pov$inc.below / dat.pov$any.income
dat.pov$pov.rate[ dat.pov$any.income == 0 ] <- 0






# median household income - "B19013_001"

my.acs <- acs.fetch( endyear=2010, 
                     geo=geo.make( state=i,county="*", tract="*"), 
                     variable="B19013_001")

state <- substr( as.character( my.acs@geography$state + 100 ), 2, 3)

county <- substr( as.character( my.acs@geography$county + 1000 ), 2, 4)

tract <- substr( as.character( as.numeric(my.acs@geography$tract) + 1000000 ), 2, 7)

tract.id <- paste( state, county, tract, sep="" )

dat.inc <- cbind( tract.id, income=my.acs@estimate[,"B19013_001"] )





# race.white - "B02001_002"

my.acs <- acs.fetch( endyear=2010, 
                     geo=geo.make( state=i, county="*", tract="*"), 
                     variable="B02001_002" )

state <- substr( as.character( my.acs@geography$state + 100 ), 2, 3)

county <- substr( as.character( my.acs@geography$county + 1000 ), 2, 4)

tract <- substr( as.character( as.numeric(my.acs@geography$tract) + 1000000 ), 2, 7)

tract.id <- paste( state, county, tract, sep="" )

dat.race.white <- cbind( tract.id, white=my.acs@estimate[,"B02001_002"] )




# race.black - "B02001_003"

my.acs <- acs.fetch( endyear=2010, 
                     geo=geo.make( state=i, county="*", tract="*"), 
                     variable="B02001_003" )

state <- substr( as.character( my.acs@geography$state + 100 ), 2, 3)

county <- substr( as.character( my.acs@geography$county + 1000 ), 2, 4)

tract <- substr( as.character( as.numeric(my.acs@geography$tract) + 1000000 ), 2, 7)

tract.id <- paste( state, county, tract, sep="" )

dat.race.black <- cbind( tract.id, black=my.acs@estimate[,"B02001_003"] )





# total population - "B01003_001"

my.acs <- acs.fetch( endyear=2010, 
                     geo=geo.make( state=i, county="*", tract="*"), 
                     variable="B01003_001" )

state <- substr( as.character( my.acs@geography$state + 100 ), 2, 3)

county <- substr( as.character( my.acs@geography$county + 1000 ), 2, 4)

tract <- substr( as.character( as.numeric(my.acs@geography$tract) + 1000000 ), 2, 7)

tract.id <- paste( state, county, tract, sep="" )

dat.pop <- cbind( tract.id, totalpop=my.acs@estimate[,"B01003_001"] )

dat.pop <- as.data.frame( dat.pop )



  
dat.pop$tract.name <- rownames(dat.pop)

dat <- merge( dat.pop, dat.pov )
dat <- merge( dat, dat.race.white )
dat <- merge( dat, dat.race.black )
dat <- merge( dat, dat.inc )
dat <- merge( dat, dat.age )
dat <- merge( dat, dat.hisp )



dat$totalpop <- as.numeric( as.character( dat$totalpop ))
dat$white <- as.numeric( as.character( dat$white ))
dat$black <- as.numeric( as.character( dat$black ))
dat$hispanic <- as.numeric( as.character( dat$hispanic ))
dat$income <- as.numeric( as.character( dat$income ))
dat$age <- as.numeric( as.character( dat$age ))

dat$pov.rate <- round( 100*dat$pov.rate, 1 )
dat$white <- round( 100*(dat$white / dat$totalpop), 1 )
dat$black <- round( 100*(dat$black / dat$totalpop), 1 )
dat$hispanic <- round( 100*(dat$hispanic / dat$totalpop), 1 )

census <- dat[ c("tract.id","tract.name","totalpop","income",
                 "age","pov.rate","white","black","hispanic") ]

names( census ) <- c("geoid","geoname","totalpop","income",
                     "medianage","poverty","white","black","hispanic")

head( census )


# write.csv( census, "TexasCensusData2010.csv", rownames=F )

```

```{r, eval=F, echo=F}

census <- read.csv( "./Census Data/Texas Census Data.csv", colClasses="character" )

```


If you want to build a dataset from multiple states at once, you will need to use a loop because the Census API limits downloads at the tract level to one state at a time. It would look something like this:

```{r, eval=F}

### CREATE A LOOP TO GRAB DATA FOR ALL STATES AND STACK

dat.pov <- NULL # poverty rate

dat.inc <- NULL # median family income

dat.race.white <- NULL  # % white 

dat.race.black <- NULL  # % black

dat.pop <- NULL # total population


state.list <- c("AL","AK","AR","AZ","CA","CO","CT","DE","FL","GA","HI","ID","IL",
                "IN","IA","KS","KY","LA","MD","MA","ME","MI","MN","MS","MO","MT",
                "NE","NV","NH","NJ","NM","NY","NC","ND","OH","OK","OR","PA","RI",
                "SC","SD","TN","TX","UT","VT","VA","WA","WI","WV","WY")  


# hispanic:  "B01001I_001"
# median age:  "B01002A_001"

acs.fetch( endyear=2010, geo=geo.make( state="TX", county="*" ), variable="B17001_001" )
acs.fetch( endyear=2010, geo=geo.make( state="TX", county="*" ), variable="B01003_001" )


for( i in state.list )
{
  
  # i <- "AL"
  
  # poverty - please double-check to make sure "B17001_001" is correct
  
  my.acs <- acs.fetch( endyear=2010, 
                       geo=geo.make( state=i, county="*", tract="*"), 
                       variable="B17001_001" )
  
  state <- substr( as.character( my.acs@geography$state + 100 ), 2, 3)
  
  county <- substr( as.character( my.acs@geography$county + 1000 ), 2, 4)
  
  tract <- substr( as.character( as.numeric(my.acs@geography$tract) + 1000000 ), 2, 7)
  
  tract.id <- paste( state, county, tract, sep="" )
  
  temp.pov <- cbind( tract.id, poverty=my.acs@estimate[,"B17001_001"] )
  
  dat.pov <- rbind( dat.pov, temp.pov )
  
  
  # median household income
  
  my.acs <- acs.fetch( endyear=2010, 
                       geo=geo.make( state=i,county="*", tract="*"), 
                       variable="B19013_001")
  
  state <- substr( as.character( my.acs@geography$state + 100 ), 2, 3)
  
  county <- substr( as.character( my.acs@geography$county + 1000 ), 2, 4)
  
  tract <- substr( as.character( as.numeric(my.acs@geography$tract) + 1000000 ), 2, 7)
  
  tract.id <- paste( state, county, tract, sep="" )
  
  temp.inc <- cbind( tract.id, income=my.acs@estimate[,"B19013_001"] )
  
  dat.inc <- rbind( dat.inc, temp.inc )
  
  
  # race.white
  
  my.acs <- acs.fetch( endyear=2010, 
                       geo=geo.make( state=i, county="*", tract="*"), 
                       variable="B02001_002" )
  
  state <- substr( as.character( my.acs@geography$state + 100 ), 2, 3)
  
  county <- substr( as.character( my.acs@geography$county + 1000 ), 2, 4)
  
  tract <- substr( as.character( as.numeric(my.acs@geography$tract) + 1000000 ), 2, 7)
  
  tract.id <- paste( state, county, tract, sep="" )
  
  temp.race.white <- cbind( tract.id, white=my.acs@estimate[,"B02001_002"] )
  
  dat.race.white <- rbind( dat.race.white, temp.race.white )
  
  # race.black
  
  my.acs <- acs.fetch( endyear=2010, 
                       geo=geo.make( state=i, county="*", tract="*"), 
                       variable="B02001_003" )
  
  state <- substr( as.character( my.acs@geography$state + 100 ), 2, 3)
  
  county <- substr( as.character( my.acs@geography$county + 1000 ), 2, 4)
  
  tract <- substr( as.character( as.numeric(my.acs@geography$tract) + 1000000 ), 2, 7)
  
  tract.id <- paste( state, county, tract, sep="" )
  
  temp.race.black <- cbind( tract.id, black=my.acs@estimate[,"B02001_003"] )
  
  dat.race.black <- rbind( dat.race.black, temp.race.black )
  
  # total population 
  
  my.acs <- acs.fetch( endyear=2010, 
                       geo=geo.make( state=i, county="*", tract="*"), 
                       variable="B01003_001" )
  
  state <- substr( as.character( my.acs@geography$state + 100 ), 2, 3)
  
  county <- substr( as.character( my.acs@geography$county + 1000 ), 2, 4)
  
  tract <- substr( as.character( as.numeric(my.acs@geography$tract) + 1000000 ), 2, 7)
  
  tract.id <- paste( state, county, tract, sep="" )
  
  temp.pop <- cbind( tract.id, totalpop=my.acs@estimate[,"B01003_001"] )
  
  dat.pop <- rbind( dat.pop, temp.pop )	
  
}



dat <- merge( dat.pov, dat.inc )

dat <- merge( dat, dat.race.white )

dat <- merge( dat, dat.race.black )

dat <- merge( dat, dat.pop )



```





# Crosswalk

Voting districts and census tracts do not all share contiguous boundaries, so merging voting data and census data can be tricky. The Missouri Census Data Center has created tools that maps voting districts to census tracts using geographic apportionment. You can visit the MABLE Geocorr14 Geographic Correspondence Engine here:

<http://mcdc.missouri.edu/websas/geocorr14.html>

A correspondence table has been created by selecting the 2010 Census Tracts and Voting Tabulation Districts and is saved as the file "crosswalk.csv".

Note, the variable **pop10** comes from the crosswalk and refers to **voting district population**. The variable **totalpop** comes from the 2010 Census ACS and refers to the **census tract population**.

![](Results/geocorr_correspondence_table.png)

Since the relationships are not nested it will not be a one-to-one relationship, i.e. one voting district can match to multiple census tracts. As a result, we select the census tract for each voting district that has the highest apportionment rate (geographical overlap). 

The mean apportionment rate is 89% (standard deviation of 17%), with a median of 100% overlap. 


```{r, echo=F, eval=F}

setwd( "C:/Users/jdlecy/Dropbox/04 - PAPERS/02 - Under Review/25 - Republican and Democratic Nonprofits/Data and Analysis" )

```


```{r}
crosswalk <- read.csv( "crosswalk.csv", colClasses="character" )

head( crosswalk )

crosswalk <- crosswalk[ -1 , ] # drop first row of labels


crosswalk$tract.key <- paste( crosswalk$county, gsub("\\.","",crosswalk$tract), sep="" )

census.dat <- merge( crosswalk, census, by.x="tract.key", by.y="geoid" )

head( census.dat )

```





# Voter Data

Data was obtained from the Harvard Election Data Archive project , a source for 2008 presidential election results at a voting district level for all 50 states. Texas contains 8,400 separate voting districts (VTDs). In the 2008 election of John McCain versus Barack Obama Texas had 1,451 Democratic supermajority districts and 2,886 Republican supermajority districts, representing 51% of all voting districts in the state.

http://projects.iq.harvard.edu/eda/

The data comes as a shapefile with historic voting data embedded, so we need to load the shapefile using the **rgdal** package in R and extract the historic voting data frame.

Select Data Dictionary:

* CNTY - County FIPS ID  
* VTD - Voting District ID  
* Shape_area - Area of voting district polygon 
* Pres_D_08 - Number of presidential votes for Democratic candidate in 2008
* Pres_R_08 - Number of presidential votes for Republican candidate in 2008





```{r, eval=F}

# library( rgdal )

TX <- readOGR(".","Texas_VTD" )

tx <- as.data.frame( TX )

head( tx )

```



```{r, echo=F}
setwd( "D:/Dropbox/04 - PAPERS/03 - Published/18 - Republican and Democratic Nonprofits/Data and Analysis/Election data and state shapefiles" )


TX <- readOGR(".","Texas_VTD" )

par( mar=c(0,0,4,0) )
plot( TX, main="All Voting Districts in TX" )
```


```{r}
tx <- as.data.frame( TX )

head( tx )

```




## Create Compatible IDs

The **vtdname** in the Census to VTD Crosswalk file, and the **vtdkey** in the Voting dataset are currently incompatible. 

The **vtdname** variables has four forms:

* 480190407  
* 48041010A, 48041010B, etc. 
* Vtng Dist 3111 
* Vtng Dist 03-3 

Each follows a format of:  SS-CCC-DIST

SS = state fips code (2 digits)
CCC = county fips code (3 digits)
DIST = voting district (4 characters)

To standardize:

```{r}

# Census Data

vtdnm <-  census.dat$vtdname

vtdnm <- gsub( "Vtng Dist ", "xxxxx", vtdnm )

head( vtdnm, 50 )

# table( nchar( vtdnm ) )  # should all be 9 characters

vtd.temp <- substr( vtdnm, 6, 9 )
  
vtd.key1 <- paste0( census.dat$county, vtd.temp )

census.dat$vtd.key1 <- vtd.key1

head( census.dat$vtd.key1, 50 )

```





```{r}

# Voting Data

# TX state fips = 48

fips <- 48000 + as.numeric( as.character( tx$CNTY ) )

vtd.key2 <- paste0( fips, as.character( tx$VTD ) )

# table( nchar( vtd.key2 ) )  # should all be 9 characters
# vtd.key2[ nchar( vtd.key2 ) == 10 ]  # not sure about these 126

tx$vtd.key2 <- vtd.key2

tx <- tx[ , c( "vtd.key2", "Pres_D_08", "Pres_R_08", "Shape_area" ) ]

head( tx )

```




## Merge Voting and Census Data

```{r}

full.dat <- merge( census.dat, tx, by.x="vtd.key1", by.y="vtd.key2" )

head( full.dat )
```




## Restrict to Supermajority Voting Districts

Restrict the sample to only districts that voted over 70% in favor of Obama in 2008, or over 70% in favor of McCain.

```{r}


full.dat$Pres_D_08 <- as.numeric( as.character( full.dat$Pres_D_08 ) )
full.dat$Pres_R_08 <- as.numeric( as.character( full.dat$Pres_R_08 ) )


vote.dem <- full.dat$Pres_D_08 / (full.dat$Pres_D_08 + full.dat$Pres_R_08)

full.dat$dem.super <- as.numeric( vote.dem > 0.70 )

full.dat$repub.super <- as.numeric( vote.dem < 0.30 )



match.dat <- full.dat[ vote.dem < 0.30 | vote.dem > 0.70 , ]

match.dat <- na.omit( match.dat )

nrow( match.dat)

head( match.dat )

```







# Match Voting Districts

For details on the matching procedures see:

Iacus, S. M., King, G., & Porro, G. (2012). Causal inference without balance checking: Coarsened exact matching. Political analysis, 20(1), 1-24.

Ho, D., Imai, K., King, G., & Stuart, E. A. (2011). MatchIt: Nonparametric Preprocessing for Parametric Causal Inference. Journal of Statistical Software,42(i08).

Sekhon, Jasjeet S. 2011. "Multivariate and Propensity Score Matching Software with Automated Balance Optimization: The Matching package for R." Journal of Statistical Software. 42(7): 1-52.


```{r}
# library( MatchIt )
# library( rgenoud )

match.dat$pop.density <- 1000 * as.numeric(match.dat$totalpop) / match.dat$Shape_area

my.dat <- match.dat[ c("geoname","vtd.key1","vtd","tract.key","county","tract",
                       "dem.super","pop.density","income",
                       "poverty","black","hispanic","medianage") ]

head( my.dat )

table( my.dat$dem.super ) 

summary( my.dat )
```


```{r}
# remove missing tract values
nrow( my.dat )
my.dat$income[ my.dat$income < 0 ] <- NA
my.dat$medianage[ my.dat$medianage < 0 ] <- NA
my.dat <- na.omit( my.dat )
nrow( my.dat )
```


## Paper Approach

This approach generates a weighted matched set using a genetic search algorith. Depending upon the underlying data, you can refined the matched sample by selecting pairs of voting districts from each set based upon matching weights. 


```{r, eval=F}

my.dat$pop.density <- my.dat$pop.density / 1000

m.out <- matchit( dem.super ~ poverty + black + pop.density, data = my.dat, 
                  method = "genetic", discard="both" )

summary( m.out )
summary( match.data(m.out, group = "treat") )
summary( match.data(m.out, group = "control") )



### Save the matched dataset

m.dat <- match.data( m.out )

nrow( m.dat )

length( unique( m.dat$vtd.key1 ))

table( m.dat$dem.super )



t.test( as.numeric(m.dat$poverty) ~ m.dat$dem.super )
t.test( as.numeric(m.dat$black) ~ m.dat$dem.super )
t.test( m.dat$pop.density ~ m.dat$dem.super )



library( ggplot2 )

ddat <- m.dat

ggplot( ddat, aes( x=poverty, fill=factor(dem.super) )) + 
        geom_density(alpha = 0.5) + # xlim(10,15) +
        xlab( "Poverty Rate" )

ggplot( ddat, aes( x=black, fill=factor(dem.super) )) + 
        geom_density(alpha = 0.5) + # xlim(10,15) +
        xlab( "Percent Black" )

ggplot( ddat, aes( x=pop.density, fill=factor(dem.super) )) + 
        geom_density(alpha = 0.5) + xlim(0,.0025) +
        xlab( "Population Density" )



```




```{r}

### CREATE A BALANCED SET WITH ONLY ONE CONTROL COUNTY FOR EACH TREATMENT COUNTY

matches <- m.out$match.matrix

setdiff( row.names( matches),  row.names( my.dat ) )  # all in model dataset

these.matched <- row.names( my.dat ) %in% row.names( matches)



# keep only the closest matches - each treatment group appears once, controls can appear many

dupes.temp <- data.frame( treat=row.names(matches), 
                          control=matches[,1], 
                          distance=m.out$distance[ these.matched ],
                          stringsAsFactors=F )

dupes.temp <- na.omit( dupes.temp[ order(dupes.temp$control) , ] )




table( m.dat$dem.super )

dupes <- NULL

for( i in unique(dupes.temp$control) )
{
    sub.dupes <- dupes.temp[ dupes.temp$control == i , ]
    
    keep <- which( sub.dupes$distance == max(sub.dupes$distance) )
    
    dupes <- rbind( dupes, sub.dupes[ keep, ] )
    
}



these.ones <- c( dupes$treat, dupes$control )

balanced <- match.dat[ row.names(my.dat) %in% these.ones , ]

table( balanced$dem.super )

head( balanced )

t.test( as.numeric(balanced$poverty) ~ balanced$dem.super )
t.test( as.numeric(balanced$black) ~ balanced$dem.super )
t.test( balanced$pop.density ~ balanced$dem.super )


ddat <- balanced

ggplot( ddat, aes( x=poverty, fill=factor(dem.super) )) + 
        geom_density(alpha = 0.5) + # xlim(10,15) +
        xlab( "Poverty Rate" )

ggplot( ddat, aes( x=black, fill=factor(dem.super) )) + 
        geom_density(alpha = 0.5) + # xlim(10,15) +
        xlab( "Percent Black" )

ggplot( ddat, aes( x=pop.density, fill=factor(dem.super) )) + 
        geom_density(alpha = 0.5) + xlim(0,25) +
        xlab( "Population Density" )


```



```{r}
##############


these.treat <- row.names(my.dat) %in% dupes$treat
these.control <- row.names(my.dat) %in% dupes$control

from.to.temp1 <- paste( match.dat[ these.treat , "vtd.key1" ], 
                        "to", match.dat[ dupes$control , "vtd.key1" ], sep="-" )

from.to.temp2 <- paste( match.dat[ these.control , "vtd.key1" ], 
                        "to", match.dat[ these.treat , "vtd.key1" ], sep="-" )

balanced$match.pair <- c( from.to.temp1, from.to.temp2 )




m.out2 <- matchit( dem.super ~ poverty + black + pop.density, data = balanced, 
                  method = "genetic", discard="both", reestimate=TRUE )

summary( m.out2 )
```


## Alternative Approach

```{r}

m.out <- matchit( dem.super ~ poverty + black + pop.density, data = my.dat, 
                  method = "genetic", discard="both", reestimate=TRUE  )

summary( m.out )
summary( match.data(m.out, group = "treat") )
summary( match.data(m.out, group = "control") )

m.dat3 <- match.data( m.out )

summary( m.dat3 )

t.test( poverty ~ dem.super, data=m.dat3 )
t.test( black ~ dem.super, data=m.dat3 )
t.test( hispanic ~ dem.super, data=m.dat3 )
t.test( medianage ~ dem.super, data=m.dat3 )
t.test( pop.density ~ dem.super, data=m.dat3 )



m.out <- matchit( dem.super ~ poverty + hispanic + medianage,
                  data=my.dat, method="exact", discard="both", reestimate=FALSE )

m.out <- matchit( dem.super ~ poverty + hispanic + medianage,
                  data=my.dat, method="exact", discard="both", reestimate=FALSE )

summary( m.out )

m.dat <- match.data( m.out )

summary( match.data(m.out, group = "treat") )
summary( match.data(m.out, group = "control") )


# Refine match by adding population density

m.out.2 <- matchit( dem.super ~ pop.density, data=m.dat, method="genetic", discard="none" )

summary( m.out.2 )

m.dat2 <- match.data( m.out.2, weights="weights2", subclass="subclass2" )

```




## Refine Matched Samples

```{r}

keep.these <- names( table( m.dat$subclass ) ) [table( m.dat$subclass ) == 2 ]
keep.these <- as.numeric( keep.these )

m.dat2 <- m.dat[ m.dat$subclass %in% keep.these , ]

m.dat2 <- m.dat2[ order(m.dat2$subclass,m.dat2$dem.super) , ]

m.dat2 <- m.dat2[ c("geoname","vtd","subclass","dem.super",
                    "income","poverty","black","hispanic","medianage","pop.density")]

m.dat2$pop.density <- round( m.dat2$pop.density, 1)
m.dat2$income <- paste0( "$",format(m.dat2$income,big.mark=","))

names(m.dat2) <- c("census.tract","votind.district","match.group","dem.super",
                   "income","poverty","black","hispanic","medianage","pop.density")

m.dat2

```


## Comparison of Group Means


```{r}

t.test( poverty ~ dem.super, data=m.dat2 )
t.test( black ~ dem.super, data=m.dat2 )
t.test( hispanic ~ dem.super, data=m.dat2 )
t.test( medianage ~ dem.super, data=m.dat2 )
t.test( pop.density ~ dem.super, data=m.dat2 )


```

















```{css, echo=F, eval=T}
p {
color: black;
margin: 0 0 20px 0;
}

td {
    padding: 3px 10px 3px 10px;
    text-align: center;
}

table
{ 
    margin-left: auto;
    margin-right: auto;
    margin-top:80px;
    margin-bottom:100px;
}

h1, h2{
  margin-top:100px;
  margin-bottom:20px;
}

H5{
    text-align: center;
    color: gray;
    font-size:0.8em;
}

img {
    max-width: 90%;
    display: block;
    margin-right: auto;
    margin-left: auto;
    margin-top:30px;
    margin-bottom:20px;
}

pre {
  overflow-x: auto;
}

pre code {
   margin-bottom:50px;
}



```


